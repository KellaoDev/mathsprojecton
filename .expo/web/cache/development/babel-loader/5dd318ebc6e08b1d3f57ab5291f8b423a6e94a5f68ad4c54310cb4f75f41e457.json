{"ast":null,"code":"import { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\nconst __DEV__ = process.env.NODE_ENV !== 'production';\nconst MAX_TOUCH_BANK = 20;\nfunction timestampForTouch(touch) {\n  return touch.timeStamp || touch.timestamp;\n}\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\nfunction getTouchIdentifier({\n  identifier\n}) {\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n  return identifier;\n}\nfunction recordTouchStart(touch, touchHistory) {\n  const identifier = getTouchIdentifier(touch);\n  const touchRecord = touchHistory.touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\nfunction recordTouchMove(touch, touchHistory) {\n  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', `Touch Move: ${printTouch(touch)}\\n`, `Touch Bank: ${printTouchBank(touchHistory)}`);\n  }\n}\nfunction recordTouchEnd(touch, touchHistory) {\n  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', `Touch End: ${printTouch(touch)}\\n`, `Touch Bank: ${printTouchBank(touchHistory)}`);\n  }\n}\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\nfunction printTouchBank(touchHistory) {\n  const {\n    touchBank\n  } = touchHistory;\n  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n  return printed;\n}\nexport class ResponderTouchHistoryStore {\n  _touchHistory = {\n    touchBank: [],\n    numberActiveTouches: 0,\n    indexOfSingleActiveTouch: -1,\n    mostRecentTimeStamp: 0\n  };\n  recordTouchTrack(topLevelType, nativeEvent) {\n    const touchHistory = this._touchHistory;\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        const {\n          touchBank\n        } = touchHistory;\n        for (let i = 0; i < touchBank.length; i++) {\n          const touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        if (__DEV__) {\n          const activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  }\n  get touchHistory() {\n    return this._touchHistory;\n  }\n}","map":{"version":3,"names":["isStartish","isMoveish","isEndish","__DEV__","process","env","NODE_ENV","MAX_TOUCH_BANK","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","identifier","console","error","recordTouchStart","touchHistory","touchBank","mostRecentTimeStamp","recordTouchMove","warn","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","ResponderTouchHistoryStore","_touchHistory","numberActiveTouches","indexOfSingleActiveTouch","recordTouchTrack","topLevelType","nativeEvent","changedTouches","forEach","touches","i","touchTrackToCheck","activeRecord"],"sources":["C:/Users/Kellao/Desktop/mathsprojecton-main/node_modules/react-native-web/src/modules/useResponderEvents/ResponderTouchHistoryStore.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type { Touch, TouchEvent } from './ResponderEventTypes';\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\n\ntype TouchRecord = {|\n  currentPageX: number,\n  currentPageY: number,\n  currentTimeStamp: number,\n  previousPageX: number,\n  previousPageY: number,\n  previousTimeStamp: number,\n  startPageX: number,\n  startPageY: number,\n  startTimeStamp: number,\n  touchActive: boolean\n|};\n\nexport type TouchHistory = $ReadOnly<{|\n  indexOfSingleActiveTouch: number,\n  mostRecentTimeStamp: number,\n  numberActiveTouches: number,\n  touchBank: Array<TouchRecord>\n|}>;\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nconst __DEV__ = process.env.NODE_ENV !== 'production';\nconst MAX_TOUCH_BANK = 20;\n\nfunction timestampForTouch(touch: Touch): number {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return (touch: any).timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch: Touch): TouchRecord {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord: TouchRecord, touch: Touch): void {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier({ identifier }: Touch): number {\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error(\n        'Touch identifier %s is greater than maximum supported %s which causes ' +\n          'performance issues backfilling array locations for all of the indices.',\n        identifier,\n        MAX_TOUCH_BANK\n      );\n    }\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch: Touch, touchHistory): void {\n  const identifier = getTouchIdentifier(touch);\n  const touchRecord = touchHistory.touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch: Touch, touchHistory): void {\n  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn(\n      'Cannot record touch move without a touch start.\\n',\n      `Touch Move: ${printTouch(touch)}\\n`,\n      `Touch Bank: ${printTouchBank(touchHistory)}`\n    );\n  }\n}\n\nfunction recordTouchEnd(touch: Touch, touchHistory): void {\n  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn(\n      'Cannot record touch end without a touch start.\\n',\n      `Touch End: ${printTouch(touch)}\\n`,\n      `Touch Bank: ${printTouchBank(touchHistory)}`\n    );\n  }\n}\n\nfunction printTouch(touch: Touch): string {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank(touchHistory): string {\n  const { touchBank } = touchHistory;\n  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n  return printed;\n}\n\nexport class ResponderTouchHistoryStore {\n  _touchHistory = {\n    touchBank: [], //Array<TouchRecord>\n    numberActiveTouches: 0,\n    // If there is only one active touch, we remember its location. This prevents\n    // us having to loop through all of the touches all the time in the most\n    // common case.\n    indexOfSingleActiveTouch: -1,\n    mostRecentTimeStamp: 0\n  };\n\n  recordTouchTrack(topLevelType: string, nativeEvent: TouchEvent): void {\n    const touchHistory = this._touchHistory;\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach((touch) =>\n        recordTouchMove(touch, touchHistory)\n      );\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach((touch) =>\n        recordTouchStart(touch, touchHistory)\n      );\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach((touch) =>\n        recordTouchEnd(touch, touchHistory)\n      );\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        const { touchBank } = touchHistory;\n        for (let i = 0; i < touchBank.length; i++) {\n          const touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        if (__DEV__) {\n          const activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  }\n\n  get touchHistory(): TouchHistory {\n    return this._touchHistory;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}