{"ast":null,"code":"import createResponderEvent from './createResponderEvent';\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from './ResponderEventTypes';\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from './utils';\nimport { ResponderTouchHistoryStore } from './ResponderTouchHistoryStore';\nimport canUseDOM from '../canUseDom';\nconst emptyObject = {};\nconst startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nconst moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nconst scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nconst shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nconst emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nconst responderListenersMap = new Map();\nlet isEmulatingMouseEvents = false;\nlet trackedTouchCount = 0;\nlet currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nconst responderTouchHistoryStore = new ResponderTouchHistoryStore();\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\nfunction getResponderConfig(id) {\n  const config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\nfunction eventListener(domEvent) {\n  const eventType = domEvent.type;\n  const eventTarget = domEvent.target;\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  if (eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  const isMoveEvent = isMoveish(eventType);\n  const isEndEvent = isEndish(eventType);\n  const isScrollEvent = isScroll(eventType);\n  const isSelectionChangeEvent = isSelectionChange(eventType);\n  const responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  let eventPaths = getResponderPaths(domEvent);\n  let wasNegotiated = false;\n  let wantsResponder;\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    const currentResponderIdPath = currentResponder.idPath;\n    const eventIdPath = eventPaths.idPath;\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      const lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        const indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        const index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n  if (currentResponder.id != null && currentResponder.node != null) {\n    const {\n      id,\n      node\n    } = currentResponder;\n    const {\n      onResponderStart,\n      onResponderMove,\n      onResponderEnd,\n      onResponderRelease,\n      onResponderTerminate,\n      onResponderTerminationRequest\n    } = getResponderConfig(id);\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      const isTerminateEvent = isCancelish(eventType) || eventType === 'contextmenu' || eventType === 'blur' && eventTarget === window || eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || isScrollEvent && trackedTouchCount === 0 || isScrollEvent && eventTarget.contains(node) && eventTarget !== node || isSelectionChangeEvent && hasValidSelection(domEvent);\n      const isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      if (isTerminateEvent) {\n        let shouldTerminate = true;\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  const shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n  if (shouldSetCallbacks != null) {\n    const {\n      idPath,\n      nodePath\n    } = eventPaths;\n    const shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    const shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    const {\n      bubbles\n    } = shouldSetCallbacks[2];\n    const check = function (id, node, callbackName) {\n      const config = getResponderConfig(id);\n      const shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          const prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id,\n            node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n    for (let i = idPath.length - 1; i >= 0; i--) {\n      const id = idPath[i];\n      const node = nodePath[i];\n      const result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n    if (bubbles) {\n      for (let i = 0; i < idPath.length; i++) {\n        const id = idPath[i];\n        const node = nodePath[i];\n        const result = check(id, node, shouldSetCallbackBubbleName);\n        if (result != null) {\n          return result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      const id = idPath[0];\n      const node = nodePath[0];\n      const target = domEvent.target;\n      if (target === node) {\n        return check(id, node, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  const {\n    id: currentId,\n    node: currentNode\n  } = currentResponder;\n  const {\n    id,\n    node\n  } = wantsResponder;\n  const {\n    onResponderGrant,\n    onResponderReject\n  } = getResponderConfig(id);\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  } else {\n    const {\n      onResponderTerminate,\n      onResponderTerminationRequest\n    } = getResponderConfig(currentId);\n    let allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\nconst documentEventsCapturePhase = ['blur', 'scroll'];\nconst documentEventsBubblePhase = ['mousedown', 'mousemove', 'mouseup', 'dragstart', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\nexport function terminateResponder() {\n  const {\n    id,\n    node\n  } = currentResponder;\n  if (id != null && node != null) {\n    const {\n      onResponderTerminate\n    } = getResponderConfig(id);\n    if (onResponderTerminate != null) {\n      const event = createResponderEvent({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\nexport function getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"names":["createResponderEvent","isCancelish","isEndish","isMoveish","isScroll","isSelectionChange","isStartish","getLowestCommonAncestor","getResponderPaths","hasTargetTouches","hasValidSelection","isPrimaryPointerDown","setResponderId","ResponderTouchHistoryStore","canUseDOM","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","responderTouchHistoryStore","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isMoveEvent","isEndEvent","isScrollEvent","isSelectionChangeEvent","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","window","contains","relatedTarget","isReleaseEvent","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","currentId","currentNode","onResponderGrant","onResponderReject","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","__reactResponderSystemActive","addEventListener","forEach","document","addNode","set","removeNode","terminateResponder","has","delete","event","getResponderNode"],"sources":["C:/Users/Kellao/Desktop/mathsprojecton-main/node_modules/react-native-web/src/modules/useResponderEvents/ResponderSystem.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\nimport type { ResponderEvent } from './createResponderEvent';\n\nimport createResponderEvent from './createResponderEvent';\nimport {\n  isCancelish,\n  isEndish,\n  isMoveish,\n  isScroll,\n  isSelectionChange,\n  isStartish\n} from './ResponderEventTypes';\nimport {\n  getLowestCommonAncestor,\n  getResponderPaths,\n  hasTargetTouches,\n  hasValidSelection,\n  isPrimaryPointerDown,\n  setResponderId\n} from './utils';\nimport { ResponderTouchHistoryStore } from './ResponderTouchHistoryStore';\nimport canUseDOM from '../canUseDom';\n\n/* ------------ TYPES ------------ */\n\ntype ResponderId = number;\n\ntype ActiveResponderInstance = {\n  id: ResponderId,\n  idPath: Array<number>,\n  node: any\n};\n\ntype EmptyResponderInstance = {\n  id: null,\n  idPath: null,\n  node: null\n};\n\ntype ResponderInstance = ActiveResponderInstance | EmptyResponderInstance;\n\nexport type ResponderConfig = {\n  // Direct responder events dispatched directly to responder. Do not bubble.\n  onResponderEnd?: ?(e: ResponderEvent) => void,\n  onResponderGrant?: ?(e: ResponderEvent) => void | boolean,\n  onResponderMove?: ?(e: ResponderEvent) => void,\n  onResponderRelease?: ?(e: ResponderEvent) => void,\n  onResponderReject?: ?(e: ResponderEvent) => void,\n  onResponderStart?: ?(e: ResponderEvent) => void,\n  onResponderTerminate?: ?(e: ResponderEvent) => void,\n  onResponderTerminationRequest?: ?(e: ResponderEvent) => boolean,\n  // On pointer down, should this element become the responder?\n  onStartShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onStartShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On pointer move, should this element become the responder?\n  onMoveShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onMoveShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On scroll, should this element become the responder? Do no bubble\n  onScrollShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onScrollShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On text selection change, should this element become the responder?\n  onSelectionChangeShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onSelectionChangeShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean\n};\n\nconst emptyObject = {};\n\n/* ------------ IMPLEMENTATION ------------ */\n\nconst startRegistration = [\n  'onStartShouldSetResponderCapture',\n  'onStartShouldSetResponder',\n  { bubbles: true }\n];\nconst moveRegistration = [\n  'onMoveShouldSetResponderCapture',\n  'onMoveShouldSetResponder',\n  { bubbles: true }\n];\nconst scrollRegistration = [\n  'onScrollShouldSetResponderCapture',\n  'onScrollShouldSetResponder',\n  { bubbles: false }\n];\nconst shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\n\nconst emptyResponder = { id: null, idPath: null, node: null };\nconst responderListenersMap = new Map();\n\nlet isEmulatingMouseEvents = false;\nlet trackedTouchCount = 0;\nlet currentResponder: ResponderInstance = {\n  id: null,\n  node: null,\n  idPath: null\n};\nconst responderTouchHistoryStore = new ResponderTouchHistoryStore();\n\nfunction changeCurrentResponder(responder: ResponderInstance) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id: ResponderId): ResponderConfig | Object {\n  const config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\nfunction eventListener(domEvent: any) {\n  const eventType = domEvent.type;\n  const eventTarget = domEvent.target;\n\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n\n  // Flag when browser may produce emulated events\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  // Remove flag when browser will not produce emulated events\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  // Ignore various events in particular circumstances\n  if (\n    // Ignore browser emulated mouse events\n    (eventType === 'mousedown' && isEmulatingMouseEvents) ||\n    (eventType === 'mousemove' && isEmulatingMouseEvents) ||\n    // Ignore mousemove if a mousedown didn't occur first\n    (eventType === 'mousemove' && trackedTouchCount < 1)\n  ) {\n    return;\n  }\n  // Remove flag after emulated events are finished\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n\n  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  const isMoveEvent = isMoveish(eventType);\n  const isEndEvent = isEndish(eventType);\n  const isScrollEvent = isScroll(eventType);\n  const isSelectionChangeEvent = isSelectionChange(eventType);\n  const responderEvent = createResponderEvent(\n    domEvent,\n    responderTouchHistoryStore\n  );\n\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    responderTouchHistoryStore.recordTouchTrack(\n      eventType,\n      responderEvent.nativeEvent\n    );\n  }\n\n  /**\n   * Responder System logic\n   */\n\n  let eventPaths = getResponderPaths(domEvent);\n  let wasNegotiated = false;\n  let wantsResponder;\n\n  // If an event occured that might change the current responder...\n  if (isStartEvent || isMoveEvent || (isScrollEvent && trackedTouchCount > 0)) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    const currentResponderIdPath = currentResponder.idPath;\n    const eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      const lowestCommonAncestor = getLowestCommonAncestor(\n        currentResponderIdPath,\n        eventIdPath\n      );\n      if (lowestCommonAncestor != null) {\n        const indexOfLowestCommonAncestor =\n          eventIdPath.indexOf(lowestCommonAncestor);\n        // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n        const index =\n          indexOfLowestCommonAncestor +\n          (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n  if (currentResponder.id != null && currentResponder.node != null) {\n    const { id, node } = currentResponder;\n    const {\n      onResponderStart,\n      onResponderMove,\n      onResponderEnd,\n      onResponderRelease,\n      onResponderTerminate,\n      onResponderTerminationRequest\n    } = getResponderConfig(id);\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    // Start\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    }\n    // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      const isTerminateEvent =\n        isCancelish(eventType) ||\n        // native context menu\n        eventType === 'contextmenu' ||\n        // window blur\n        (eventType === 'blur' && eventTarget === window) ||\n        // responder (or ancestors) blur\n        (eventType === 'blur' &&\n          eventTarget.contains(node) &&\n          domEvent.relatedTarget !== node) ||\n        // native scroll without using a pointer\n        (isScrollEvent && trackedTouchCount === 0) ||\n        // native scroll on node that is parent of the responder (allow siblings to scroll)\n        (isScrollEvent && eventTarget.contains(node) && eventTarget !== node) ||\n        // native select/selectionchange on node\n        (isSelectionChangeEvent && hasValidSelection(domEvent));\n\n      const isReleaseEvent =\n        isEndEvent &&\n        !isTerminateEvent &&\n        !hasTargetTouches(node, domEvent.touches);\n\n      // End\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n      // Release\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      // Terminate\n      if (isTerminateEvent) {\n        let shouldTerminate = true;\n\n        // Responders can still avoid termination but only for these events.\n        if (\n          eventType === 'contextmenu' ||\n          eventType === 'scroll' ||\n          eventType === 'selectionchange'\n        ) {\n          // Only call this function is it wasn't already called during negotiation.\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName =\n              'onResponderTerminationRequest';\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName =\n              'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  const shouldSetCallbacks = shouldSetResponderEvents[(domEvent.type: any)]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    const { idPath, nodePath } = eventPaths;\n\n    const shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    const shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    const { bubbles } = shouldSetCallbacks[2];\n\n    const check = function (id, node, callbackName) {\n      const config = getResponderConfig(id);\n      const shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          // Start the path from the potential responder\n          const prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return { id, node, idPath: prunedIdPath };\n        }\n      }\n    };\n\n    // capture\n    for (let i = idPath.length - 1; i >= 0; i--) {\n      const id = idPath[i];\n      const node = nodePath[i];\n      const result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    // bubble\n    if (bubbles) {\n      for (let i = 0; i < idPath.length; i++) {\n        const id = idPath[i];\n        const node = nodePath[i];\n        const result = check(id, node, shouldSetCallbackBubbleName);\n        if (result != null) {\n          return result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      const id = idPath[0];\n      const node = nodePath[0];\n      const target = domEvent.target;\n      if (target === node) {\n        return check(id, node, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\n/**\n * Attempt to transfer the responder.\n */\nfunction attemptTransfer(\n  responderEvent: ResponderEvent,\n  wantsResponder: ActiveResponderInstance\n) {\n  const { id: currentId, node: currentNode } = currentResponder;\n  const { id, node } = wantsResponder;\n\n  const { onResponderGrant, onResponderReject } = getResponderConfig(id);\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  // Set responder\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  }\n  // Negotiate with current responder\n  else {\n    const { onResponderTerminate, onResponderTerminationRequest } =\n      getResponderConfig(currentId);\n\n    let allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName =\n        'onResponderTerminationRequest';\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n      // Grant next responder\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\nconst documentEventsCapturePhase = ['blur', 'scroll'];\nconst documentEventsBubblePhase = [\n  // mouse\n  'mousedown',\n  'mousemove',\n  'mouseup',\n  'dragstart',\n  // touch\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n  // other\n  'contextmenu',\n  'select',\n  'selectionchange'\n];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach((eventType) => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach((eventType) => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n\n/**\n * Register a node with the ResponderSystem.\n */\nexport function addNode(id: ResponderId, node: any, config: ResponderConfig) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n\n/**\n * Unregister a node with the ResponderSystem.\n */\nexport function removeNode(id: ResponderId) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\nexport function terminateResponder() {\n  const { id, node } = currentResponder;\n  if (id != null && node != null) {\n    const { onResponderTerminate } = getResponderConfig(id);\n    if (onResponderTerminate != null) {\n      const event = createResponderEvent({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\nexport function getResponderNode(): any {\n  return currentResponder.node;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}