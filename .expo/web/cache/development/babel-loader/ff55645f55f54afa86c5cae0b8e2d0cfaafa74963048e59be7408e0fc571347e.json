{"ast":null,"code":"import getBoundingClientRect from '../../modules/getBoundingClientRect';\nconst emptyFunction = () => {};\nconst emptyObject = {};\nconst emptyArray = [];\nfunction normalizeIdentifier(identifier) {\n  return identifier > 20 ? identifier % 20 : identifier;\n}\nexport default function createResponderEvent(domEvent, responderTouchHistoryStore) {\n  let rect;\n  let propagationWasStopped = false;\n  let changedTouches;\n  let touches;\n  const domEventChangedTouches = domEvent.changedTouches;\n  const domEventType = domEvent.type;\n  const metaKey = domEvent.metaKey === true;\n  const shiftKey = domEvent.shiftKey === true;\n  const force = domEventChangedTouches && domEventChangedTouches[0].force || 0;\n  const identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);\n  const clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;\n  const clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;\n  const pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;\n  const pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;\n  const preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;\n  const timestamp = domEvent.timeStamp;\n  function normalizeTouches(touches) {\n    return Array.prototype.slice.call(touches).map(touch => {\n      return {\n        force: touch.force,\n        identifier: normalizeIdentifier(touch.identifier),\n        get locationX() {\n          return locationX(touch.clientX);\n        },\n        get locationY() {\n          return locationY(touch.clientY);\n        },\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        target: touch.target,\n        timestamp\n      };\n    });\n  }\n  if (domEventChangedTouches != null) {\n    changedTouches = normalizeTouches(domEventChangedTouches);\n    touches = normalizeTouches(domEvent.touches);\n  } else {\n    const emulatedTouches = [{\n      force,\n      identifier,\n      get locationX() {\n        return locationX(clientX);\n      },\n      get locationY() {\n        return locationY(clientY);\n      },\n      pageX,\n      pageY,\n      target: domEvent.target,\n      timestamp\n    }];\n    changedTouches = emulatedTouches;\n    touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;\n  }\n  const responderEvent = {\n    bubbles: true,\n    cancelable: true,\n    currentTarget: null,\n    defaultPrevented: domEvent.defaultPrevented,\n    dispatchConfig: emptyObject,\n    eventPhase: domEvent.eventPhase,\n    isDefaultPrevented() {\n      return domEvent.defaultPrevented;\n    },\n    isPropagationStopped() {\n      return propagationWasStopped;\n    },\n    isTrusted: domEvent.isTrusted,\n    nativeEvent: {\n      altKey: false,\n      ctrlKey: false,\n      metaKey,\n      shiftKey,\n      changedTouches,\n      force,\n      identifier,\n      get locationX() {\n        return locationX(clientX);\n      },\n      get locationY() {\n        return locationY(clientY);\n      },\n      pageX,\n      pageY,\n      target: domEvent.target,\n      timestamp,\n      touches,\n      type: domEventType\n    },\n    persist: emptyFunction,\n    preventDefault,\n    stopPropagation() {\n      propagationWasStopped = true;\n    },\n    target: domEvent.target,\n    timeStamp: timestamp,\n    touchHistory: responderTouchHistoryStore.touchHistory\n  };\n  function locationX(x) {\n    rect = rect || getBoundingClientRect(responderEvent.currentTarget);\n    if (rect) {\n      return x - rect.left;\n    }\n  }\n  function locationY(y) {\n    rect = rect || getBoundingClientRect(responderEvent.currentTarget);\n    if (rect) {\n      return y - rect.top;\n    }\n  }\n  return responderEvent;\n}","map":{"version":3,"names":["getBoundingClientRect","emptyFunction","emptyObject","emptyArray","normalizeIdentifier","identifier","createResponderEvent","domEvent","responderTouchHistoryStore","rect","propagationWasStopped","changedTouches","touches","domEventChangedTouches","domEventType","type","metaKey","shiftKey","force","clientX","clientY","pageX","pageY","preventDefault","bind","timestamp","timeStamp","normalizeTouches","Array","prototype","slice","call","map","touch","locationX","locationY","target","emulatedTouches","responderEvent","bubbles","cancelable","currentTarget","defaultPrevented","dispatchConfig","eventPhase","isDefaultPrevented","isPropagationStopped","isTrusted","nativeEvent","altKey","ctrlKey","persist","stopPropagation","touchHistory","x","left","y","top"],"sources":["C:/Users/Kellao/Desktop/mathsprojecton-main/node_modules/react-native-web/src/modules/useResponderEvents/createResponderEvent.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ResponderTouchHistoryStore,\n  TouchHistory\n} from './ResponderTouchHistoryStore';\nimport type { TouchEvent } from './ResponderEventTypes';\n\nimport getBoundingClientRect from '../../modules/getBoundingClientRect';\n\nexport type ResponderEvent = {|\n  bubbles: boolean,\n  cancelable: boolean,\n  currentTarget: any,\n  defaultPrevented: ?boolean,\n  dispatchConfig: {\n    registrationName?: string,\n    phasedRegistrationNames?: {\n      bubbled: string,\n      captured: string\n    }\n  },\n  eventPhase: ?number,\n  isDefaultPrevented: () => boolean,\n  isPropagationStopped: () => boolean,\n  isTrusted: ?boolean,\n  preventDefault: () => void,\n  stopPropagation: () => void,\n  nativeEvent: TouchEvent,\n  persist: () => void,\n  target: ?any,\n  timeStamp: number,\n  touchHistory: TouchHistory\n|};\n\nconst emptyFunction = () => {};\nconst emptyObject = {};\nconst emptyArray = [];\n\n/**\n * Safari produces very large identifiers that would cause the `touchBank` array\n * length to be so large as to crash the browser, if not normalized like this.\n * In the future the `touchBank` should use an object/map instead.\n */\nfunction normalizeIdentifier(identifier) {\n  return identifier > 20 ? identifier % 20 : identifier;\n}\n\n/**\n * Converts a native DOM event to a ResponderEvent.\n * Mouse events are transformed into fake touch events.\n */\nexport default function createResponderEvent(\n  domEvent: any,\n  responderTouchHistoryStore: ResponderTouchHistoryStore\n): ResponderEvent {\n  let rect;\n  let propagationWasStopped = false;\n  let changedTouches;\n  let touches;\n\n  const domEventChangedTouches = domEvent.changedTouches;\n  const domEventType = domEvent.type;\n\n  const metaKey = domEvent.metaKey === true;\n  const shiftKey = domEvent.shiftKey === true;\n  const force =\n    (domEventChangedTouches && domEventChangedTouches[0].force) || 0;\n  const identifier = normalizeIdentifier(\n    (domEventChangedTouches && domEventChangedTouches[0].identifier) || 0\n  );\n  const clientX =\n    (domEventChangedTouches && domEventChangedTouches[0].clientX) ||\n    domEvent.clientX;\n  const clientY =\n    (domEventChangedTouches && domEventChangedTouches[0].clientY) ||\n    domEvent.clientY;\n  const pageX =\n    (domEventChangedTouches && domEventChangedTouches[0].pageX) ||\n    domEvent.pageX;\n  const pageY =\n    (domEventChangedTouches && domEventChangedTouches[0].pageY) ||\n    domEvent.pageY;\n  const preventDefault =\n    typeof domEvent.preventDefault === 'function'\n      ? domEvent.preventDefault.bind(domEvent)\n      : emptyFunction;\n  const timestamp = domEvent.timeStamp;\n\n  function normalizeTouches(touches) {\n    return Array.prototype.slice.call(touches).map((touch) => {\n      return {\n        force: touch.force,\n        identifier: normalizeIdentifier(touch.identifier),\n        get locationX() {\n          return locationX(touch.clientX);\n        },\n        get locationY() {\n          return locationY(touch.clientY);\n        },\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        target: touch.target,\n        timestamp\n      };\n    });\n  }\n\n  if (domEventChangedTouches != null) {\n    changedTouches = normalizeTouches(domEventChangedTouches);\n    touches = normalizeTouches(domEvent.touches);\n  } else {\n    const emulatedTouches = [\n      {\n        force,\n        identifier,\n        get locationX() {\n          return locationX(clientX);\n        },\n        get locationY() {\n          return locationY(clientY);\n        },\n        pageX,\n        pageY,\n        target: domEvent.target,\n        timestamp\n      }\n    ];\n    changedTouches = emulatedTouches;\n    touches =\n      domEventType === 'mouseup' || domEventType === 'dragstart'\n        ? emptyArray\n        : emulatedTouches;\n  }\n\n  const responderEvent = {\n    bubbles: true,\n    cancelable: true,\n    // `currentTarget` is set before dispatch\n    currentTarget: null,\n    defaultPrevented: domEvent.defaultPrevented,\n    dispatchConfig: emptyObject,\n    eventPhase: domEvent.eventPhase,\n    isDefaultPrevented() {\n      return domEvent.defaultPrevented;\n    },\n    isPropagationStopped() {\n      return propagationWasStopped;\n    },\n    isTrusted: domEvent.isTrusted,\n    nativeEvent: {\n      altKey: false,\n      ctrlKey: false,\n      metaKey,\n      shiftKey,\n      changedTouches,\n      force,\n      identifier,\n      get locationX() {\n        return locationX(clientX);\n      },\n      get locationY() {\n        return locationY(clientY);\n      },\n      pageX,\n      pageY,\n      target: domEvent.target,\n      timestamp,\n      touches,\n      type: domEventType\n    },\n    persist: emptyFunction,\n    preventDefault,\n    stopPropagation() {\n      propagationWasStopped = true;\n    },\n    target: domEvent.target,\n    timeStamp: timestamp,\n    touchHistory: responderTouchHistoryStore.touchHistory\n  };\n\n  // Using getters and functions serves two purposes:\n  // 1) The value of `currentTarget` is not initially available.\n  // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.\n  function locationX(x) {\n    rect = rect || getBoundingClientRect(responderEvent.currentTarget);\n    if (rect) {\n      return x - rect.left;\n    }\n  }\n  function locationY(y) {\n    rect = rect || getBoundingClientRect(responderEvent.currentTarget);\n    if (rect) {\n      return y - rect.top;\n    }\n  }\n\n  return responderEvent;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}